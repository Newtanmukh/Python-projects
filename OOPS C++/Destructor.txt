Destructor is invoked automatically by the compiler when its corresponding constructor goes out of scope and releases the memory space that is no longer required by the program.
that is it will be invoked instantly once the scope of the object is over.

Destructor neither requires any argument nor returns any value therefore it CANNOT be overloaded.

Destructor  cannot be declared as static and const.

Destructor should be declared in the public section of the program.

Destructor is called in the reverse order of its constructor invocation.

a virtual destructor ensures that when derived subclasses go out of scope or are deleted the order of destruction of each class in a hierarchy is carried out correctly.
If the destruction order of the class objects is incorrect, in can lead to what is known as a memory leak. 


EXAMPLE : 

#include <iostream>
using namespace std;

class Test {
public:
 Test();

 ~Test();
 
 int f(int x,int y,int z);
 
};

Test::~Test()
{
    cout<<"Destructor Invoked"<<endl;
}

Test::Test()
{
    cout<<"Constructor Invoked"<<endl;
}

int Test::f(int x, int y, int z)
{
    return x+y+z;
}

int main()
{
 Test t;
    
    int l=t.f(2,3,5);
    
    cout<<l<<endl;
 return 0;
}
